/**
 * LingoFriends â€” Lesson Assembler
 *
 * DETERMINISTIC lesson assembly from AI-generated chunk content.
 *
 * ARCHITECTURE RULE (see .clinerules):
 *   The AI generates CONTENT (phrases, translations, distractors, contexts).
 *   This module builds ACTIVITIES (ActivityConfig objects).
 *   These two concerns are NEVER mixed.
 *
 * Every chunk goes through the teach-first 5-step progression:
 *   1. INTRODUCE â€” Show chunk + translation (INFO, 0 SunDrops)
 *   2. RECOGNIZE â€” "What does X mean?" MC in native language (1 SunDrop)
 *   3. PRACTICE  â€” Fill blank with last word (2 SunDrops)
 *   4. RECALL    â€” Translate native â†’ target (3 SunDrops)
 *   5. APPLY     â€” "When would you say X?" context MC (2 SunDrops)
 *
 * This module has ZERO dependency on the AI client. It is pure TypeScript
 * and always produces valid, fully-populated ActivityConfig objects.
 *
 * @module lessonAssembler
 */

import { GameActivityType } from '../types/game';
import type { ActivityConfig, LessonStep, LessonPlan } from '../types/game';
import { toLanguageName } from '../utils/languageUtils';

// ============================================================================
// TYPES â€” THE ONLY INTERFACE BETWEEN AI OUTPUT AND LESSON ASSEMBLY
// ============================================================================

/**
 * A single lexical chunk generated by the AI.
 *
 * CRITICAL CONTRACT:
 * - All distractors MUST be in the NATIVE language (same as nativeTranslation).
 *   Example for "Guten Morgen" (native = English):
 *     distractors: ["Good evening", "Good night", "Goodbye"]  âœ…
 *     distractors: ["Guten Abend", "Gute Nacht", "TschÃ¼ss"]   âŒ (target language!)
 *
 * - All usage contexts MUST be in the NATIVE language.
 *
 * If the AI doesn't follow these rules, the validator will catch it.
 */
export interface GeneratedChunkContent {
  /** Phrase in the target language: "Guten Morgen" */
  targetPhrase: string;

  /** Translation in the native language: "Good morning" */
  nativeTranslation: string;

  /** Example sentence using the phrase in the target language: "Guten Morgen! Wie geht's?" */
  exampleSentence: string;

  /** When/how to use this phrase, in the native language: "Use as a morning greeting" */
  usageNote: string;

  /** Child-friendly explanation in the native language: "A polite way to say hello in the morning" */
  explanation: string;

  /**
   * 3 wrong translations in the NATIVE language.
   * Must be plausible (same semantic category) but clearly wrong.
   * NEVER in the target language.
   */
  distractors: [string, string, string];

  /** The correct situation for using this phrase, in the native language */
  correctUsageContext: string;

  /**
   * 3 wrong usage situations in the NATIVE language.
   * Must be plausible but incorrect.
   */
  wrongUsageContexts: [string, string, string];
}

/**
 * Complete AI output for a lesson â€” CONTENT ONLY, no activity structure.
 * This is assembled into a LessonPlan by assembleLessonPlan().
 */
export interface AILessonContent {
  /** Lesson display title, e.g. "Morning Greetings" */
  title: string;

  /** Target language ISO code, e.g. "de" */
  targetLanguageCode: string;

  /** Native language ISO code, e.g. "en" */
  nativeLanguageCode: string;

  /** The chunks to teach in this lesson (2â€“4 recommended) */
  chunks: GeneratedChunkContent[];

  /** Learner interests used for personalising tutor text */
  interests?: string[];
}

// ============================================================================
// PUBLIC API
// ============================================================================

/**
 * Assemble a complete LessonPlan from AI-generated chunk content.
 *
 * This function is DETERMINISTIC â€” same input always produces same output.
 * It NEVER calls the AI or makes any network requests.
 *
 * @param content - AI-generated chunk content (from generateChunksForTopic)
 * @param lessonId - Unique lesson ID supplied by the caller
 * @returns A fully populated LessonPlan ready for LessonView
 */
export function assembleLessonPlan(
  content: AILessonContent,
  lessonId: string
): LessonPlan {
  const targetLangName = toLanguageName(content.targetLanguageCode);
  const steps: LessonStep[] = [];

  // Each chunk contributes exactly 5 steps
  for (const chunk of content.chunks) {
    steps.push(...assembleTeachFirstSteps(chunk, targetLangName));
  }

  // Sum sunDrops from all steps
  const totalSunDrops = steps.reduce((sum, step) => sum + step.activity.sunDrops, 0);

  console.log(
    `[lessonAssembler] Assembled ${steps.length} steps for ${content.chunks.length} chunks ` +
    `(${totalSunDrops} SunDrops total)`
  );

  return {
    id: lessonId,
    title: content.title,
    icon: 'ðŸ“š',
    skillPathId: content.title,
    lessonIndex: 0,
    steps,
    totalSunDrops,
  };
}

/**
 * Get the correct option index for a shuffled multiple-choice question.
 *
 * Deterministic: same answer string â†’ same position every time.
 * The correct answer won't always be at index 0 (which is obviously wrong)
 * but the position is stable across renders.
 *
 * @param correctAnswer - The correct option text
 * @returns Index 0-3
 */
export function getCorrectIndex(correctAnswer: string): number {
  // Use string length mod 4 â€” simple, deterministic, distributes across 0-3
  return correctAnswer.length % 4;
}

// ============================================================================
// CORE ASSEMBLY â€” TEACH-FIRST 5-STEP PROGRESSION
// ============================================================================

/**
 * Build the 5 teach-first steps for a single chunk.
 *
 * ORDER IS MANDATORY:
 *   1. INTRODUCE  (INFO)            â€” learner sees the phrase first
 *   2. RECOGNIZE  (MULTIPLE_CHOICE) â€” guided MC with hint available
 *   3. PRACTICE   (FILL_BLANK)      â€” complete part of the phrase
 *   4. RECALL     (TRANSLATE)       â€” full translation from native to target
 *   5. APPLY      (MULTIPLE_CHOICE) â€” contextual usage question
 */
function assembleTeachFirstSteps(
  chunk: GeneratedChunkContent,
  targetLangName: string
): LessonStep[] {
  return [
    buildIntroduceStep(chunk),
    buildRecognizeStep(chunk),
    buildPracticeStep(chunk),
    buildRecallStep(chunk, targetLangName),
    buildApplyStep(chunk),
  ];
}

// â”€â”€ STEP 1: INTRODUCE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Show the phrase + translation. No quiz. No pressure.
 * The learner MUST see this before any quiz step.
 */
function buildIntroduceStep(chunk: GeneratedChunkContent): LessonStep {
  return {
    tutorText: `ðŸ“š New phrase: "${chunk.targetPhrase}"`,
    helpText: chunk.explanation,
    activity: {
      type: GameActivityType.INFO,
      title: chunk.targetPhrase,
      content: `${chunk.targetPhrase} = "${chunk.nativeTranslation}"`,
      explanation: chunk.explanation,
      example: chunk.exampleSentence,
      sunDrops: 0,
    },
  };
}

// â”€â”€ STEP 2: RECOGNIZE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Multiple choice: "What does [target phrase] mean?"
 * Options are all in the NATIVE language (correct answer + 3 distractors).
 * Hint reminds the learner of the answer â€” this is GUIDED practice.
 */
function buildRecognizeStep(chunk: GeneratedChunkContent): LessonStep {
  const options = shuffleWithCorrectAt(chunk.nativeTranslation, chunk.distractors);
  const correctIndex = getCorrectIndex(chunk.nativeTranslation);

  return {
    tutorText: `Let's check â€” what does "${chunk.targetPhrase}" mean?`,
    helpText: `Remember: "${chunk.targetPhrase}" = "${chunk.nativeTranslation}"`,
    activity: {
      type: GameActivityType.MULTIPLE_CHOICE,
      question: `What does "${chunk.targetPhrase}" mean?`,
      options,
      correctIndex,
      hint: `"${chunk.targetPhrase}" = "${chunk.nativeTranslation}"`,
      sunDrops: 1,
    },
  };
}

// â”€â”€ STEP 3: PRACTICE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Fill in the blank â€” recall part of the phrase.
 *
 * Multi-word phrase â†’ blank the last word: "Guten ___"
 * Single-word phrase â†’ "___ = 'translation'" format
 *
 * Hint is available but not shown by default.
 */
function buildPracticeStep(chunk: GeneratedChunkContent): LessonStep {
  const sentence = buildFillBlankSentence(chunk);
  const correctAnswer = getFillBlankAnswer(chunk);
  const acceptedAnswers = getFillBlankAcceptedAnswers(chunk);

  return {
    tutorText: `Practice time! Complete this phrase.`,
    helpText: `The full phrase is: "${chunk.targetPhrase}"`,
    activity: {
      type: GameActivityType.FILL_BLANK,
      sentence,
      correctAnswer,
      acceptedAnswers,
      hint: `"${chunk.targetPhrase}" = "${chunk.nativeTranslation}"`,
      sunDrops: 2,
    },
  };
}

// â”€â”€ STEP 4: RECALL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Translate from native language to target language.
 * No hints shown by default â€” this is where retention is tested.
 * Multiple accepted answer variants handle capitalisation and punctuation.
 */
function buildRecallStep(chunk: GeneratedChunkContent, targetLangName: string): LessonStep {
  const acceptedAnswers = getTranslateAcceptedAnswers(chunk);

  return {
    tutorText: `Your turn! How do you say "${chunk.nativeTranslation}" in ${targetLangName}?`,
    helpText: `Think about the phrase we just practised...`,
    activity: {
      type: GameActivityType.TRANSLATE,
      sourcePhrase: chunk.nativeTranslation,
      // correctAnswer is the canonical form â€” Translate.tsx requires this for its
      // validation check and "show answer after X wrong attempts" feature.
      // acceptedAnswers includes lowercase/punctuation variants so kids aren't penalised.
      correctAnswer: chunk.targetPhrase,
      acceptedAnswers,
      hint: `It starts with "${chunk.targetPhrase.substring(0, 3)}..."`,
      sunDrops: 3,
    },
  };
}

// â”€â”€ STEP 5: APPLY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Contextual multiple choice: "When would you say [phrase]?"
 * Options are all in the NATIVE language (correct situation + 3 wrong situations).
 */
function buildApplyStep(chunk: GeneratedChunkContent): LessonStep {
  const options = shuffleWithCorrectAt(chunk.correctUsageContext, chunk.wrongUsageContexts);
  const correctIndex = getCorrectIndex(chunk.correctUsageContext);

  return {
    tutorText: `Great! Now, when would you say "${chunk.targetPhrase}"?`,
    helpText: chunk.usageNote,
    activity: {
      type: GameActivityType.MULTIPLE_CHOICE,
      question: `When would you say "${chunk.targetPhrase}"?`,
      options,
      correctIndex,
      hint: chunk.usageNote,
      sunDrops: 2,
    },
  };
}

// ============================================================================
// HELPERS
// ============================================================================

/**
 * Shuffle options so the correct answer lands at a deterministic position.
 *
 * Position = correctAnswer.length % 4, so it varies by content
 * but is stable across renders. This prevents the correct answer from
 * always appearing at index 0 (too obvious) while remaining testable.
 *
 * @param correctAnswer - The correct option text
 * @param wrongAnswers - Exactly 3 wrong options
 * @returns Array of 4 options with correct answer at getCorrectIndex() position
 */
function shuffleWithCorrectAt(
  correctAnswer: string,
  wrongAnswers: [string, string, string]
): string[] {
  const position = getCorrectIndex(correctAnswer);
  // Start with the 3 wrong answers
  const options: string[] = [...wrongAnswers];
  // Insert correct answer at the calculated position
  options.splice(position, 0, correctAnswer);
  return options;
}

/**
 * Build the fill-in-the-blank sentence string.
 *
 * Multi-word: blank the last word â†’ "Guten ___"
 * Single word: use format        â†’ "___ = 'Good morning'"
 */
function buildFillBlankSentence(chunk: GeneratedChunkContent): string {
  const words = chunk.targetPhrase.split(/\s+/);
  if (words.length >= 2) {
    // Blank the last word: "Guten ___"
    return words.slice(0, -1).join(' ') + ' ___';
  }
  // Single word: "___ = 'translation'"
  return `___ = "${chunk.nativeTranslation}"`;
}

/**
 * Get the expected fill-in-the-blank answer.
 *
 * For multi-word phrases, this is the last word.
 * For single words, this is the whole word.
 */
function getFillBlankAnswer(chunk: GeneratedChunkContent): string {
  const words = chunk.targetPhrase.split(/\s+/);
  return words.length >= 2 ? words[words.length - 1] : chunk.targetPhrase;
}

/**
 * Get all accepted answers for fill-in-the-blank, including:
 * - Exact answer
 * - Lowercase variant
 * - Punctuation-stripped variants
 *
 * Deduplicated to avoid redundant entries.
 */
function getFillBlankAcceptedAnswers(chunk: GeneratedChunkContent): string[] {
  const answer = getFillBlankAnswer(chunk);
  const stripped = answer.replace(/[!?.,;:]/g, '').trim();
  return [...new Set([
    answer,
    answer.toLowerCase(),
    stripped,
    stripped.toLowerCase(),
  ])];
}

/**
 * Get all accepted answers for the translate step.
 *
 * Includes the exact phrase, lowercase variant, and punctuation-stripped
 * variants so kids don't get penalised for minor formatting differences.
 */
function getTranslateAcceptedAnswers(chunk: GeneratedChunkContent): string[] {
  const phrase = chunk.targetPhrase;
  const stripped = phrase.replace(/[!?.,;:]/g, '').trim();
  return [...new Set([
    phrase,
    phrase.toLowerCase(),
    stripped,
    stripped.toLowerCase(),
  ])];
}
